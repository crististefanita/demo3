<!DOCTYPE html>

<html lang="ro">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>Living Architecture (UI + API) — Canonical v1.0</title>
<style>
  :root {
   --bg: #0b0f14;
   --panel: #111826;
   --panel2: #0f1724;
   --text: #e6edf3;
   --muted: #a8b3cf;
   --border: #243044;
   --accent: #7aa2ff;
   --accent2: #6ee7b7;
   --warn: #fbbf24;
   --bad: #fb7185;
   --good: #34d399;
   --codebg: #0a0f18;
   --shadow: rgba(0,0,0,.35);
   --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
   --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
  }
  html, body { height: 100%; }
  body {
   margin: 0;
   font-family: var(--sans);
   background: radial-gradient(1200px 800px at 10% 0%, #142038 0%, var(--bg) 45%) fixed;
   color: var(--text);
   line-height: 1.55;
  }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }
  .wrap { max-width: 1150px; margin: 0 auto; padding: 28px 18px 60px; }
  header {
   background: linear-gradient(180deg, rgba(17,24,38,.85), rgba(17,24,38,.35));
   border: 1px solid var(--border);
   box-shadow: 0 12px 30px var(--shadow);
   border-radius: 18px;
   padding: 22px 22px 18px;
   margin-bottom: 16px;
  }
  h1 { margin: 0 0 6px; font-size: 26px; letter-spacing: .2px; }
  .sub { color: var(--muted); font-size: 14px; }
  .badge {
   display: inline-block; padding: 3px 10px; border-radius: 999px;
   border: 1px solid var(--border); background: rgba(15,23,36,.75);
   font-size: 12px; color: var(--muted); margin-left: 8px;
  }
  .grid {
   display: grid;
   grid-template-columns: 1.2fr .8fr;
   gap: 14px;
   margin-top: 14px;
  }
  @media (max-width: 980px) {
   .grid { grid-template-columns: 1fr; }
  }
  .card {
   border: 1px solid var(--border);
   border-radius: 16px;
   background: rgba(17,24,38,.72);
   box-shadow: 0 10px 26px var(--shadow);
   padding: 16px 16px 14px;
  }
  .card h2 { margin: 0 0 10px; font-size: 18px; }
  .kvs { display: grid; grid-template-columns: 180px 1fr; gap: 8px 12px; }
  .k { color: var(--muted); }
  code.inline {
   font-family: var(--mono); font-size: 12.5px;
   background: rgba(10,15,24,.75);
   border: 1px solid var(--border);
   padding: 2px 6px; border-radius: 8px;
  }
  pre {
   background: rgba(10,15,24,.88);
   border: 1px solid var(--border);
   border-radius: 14px;
   padding: 12px 12px;
   overflow: auto;
   box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
   margin: 10px 0 0;
  }
  pre code {
   font-family: var(--mono);
   font-size: 12.5px;
   color: #dbe7ff;
   white-space: pre;
  }
  .note {
   border-left: 3px solid var(--accent2);
   padding: 10px 12px;
   background: rgba(16, 185, 129, .08);
   border-radius: 12px;
   color: var(--text);
  }
  .warn {
   border-left: 3px solid var(--warn);
   padding: 10px 12px;
   background: rgba(251, 191, 36, .08);
   border-radius: 12px;
  }
  .rule {
   border-left: 3px solid var(--accent);
   padding: 10px 12px;
   background: rgba(122, 162, 255, .08);
   border-radius: 12px;
   margin: 10px 0;
  }
  .pill {
   display:inline-block; font-size: 12px; padding: 2px 8px;
   border-radius: 999px; border: 1px solid var(--border);
   background: rgba(15,23,36,.7); color: var(--muted);
   margin-right: 6px;
  }
  details {
   border: 1px solid var(--border);
   background: rgba(15,23,36,.55);
   border-radius: 16px;
   padding: 10px 12px;
   margin: 12px 0;
   box-shadow: 0 8px 22px var(--shadow);
  }
  summary {
   cursor: pointer;
   list-style: none;
   font-weight: 600;
   color: var(--text);
   display: flex;
   align-items: center;
   justify-content: space-between;
   gap: 10px;
   padding: 4px 2px;
  }
  summary::-webkit-details-marker { display:none; }
  .sumhint { color: var(--muted); font-weight: 400; font-size: 12px; }
  .split {
   display:grid; grid-template-columns: 1fr 1fr; gap: 12px;
  }
  @media (max-width: 980px) {
   .split { grid-template-columns: 1fr; }
  }
  .mini h3 { margin: 8px 0 8px; font-size: 15px; }
  ul { margin: 8px 0 0 18px; }
  li { margin: 4px 0; }
  hr.sep { border: 0; border-top: 1px solid var(--border); margin: 16px 0; }
  .muted { color: var(--muted); }

  /* Diagram framing (match preview) */
  .diag {
   background: #020617;
   border: 1px solid #334;
   border-radius: 12px;
   padding: 12px;
   overflow: auto;
   margin-top: 10px;
  }
  .diag svg { display: block; background: #020617; border-radius: 10px; }
  .diag details { margin-top: 10px; box-shadow: none; }
  .diag details summary { color: #93c5fd; font-weight: 600; }
 
/* ===== Compact spacing for spec / MUST sections ===== */
details h4 {
  margin: 10px 0 6px;
}

details ul {
  margin: 4px 0 6px 18px;
}

details li {
  margin: 2px 0;
}

code.inline {
  line-height: 1.2;
}

details {
  margin: 10px 0;
  padding: 8px 10px;
}

summary {
  padding: 2px 2px;
}

details pre {
  margin-top: 6px;
}

</style>
</head>
<body>
<div class="wrap">
<header>
<h1>Living Architecture (UI + API) — Canonical <span class="badge">v1.0</span></h1>
<div class="sub">Document canonic pentru arhitectura UI + API (versiune v1_0).</div>
</header>
<div class="grid">
<div class="card">
<h2>1) Abordare</h2>
<div class="kvs">
  <div class="k">Technology</div>
  <div>
    <code class="inline">Java 11</code> ·
    <code class="inline">Maven</code> ·
    <code class="inline">TestNG</code> ·
    <code class="inline">RestAssured</code>
  </div>
  <div class="k">Structură proiect</div>
  <div>
    <b>Un singur proiect Maven</b>, cu un singur
    <code class="inline">src</code>
    (<code class="inline">src/main</code>, <code class="inline">src/test</code>);
    separare exclusiv logică, prin pachete Java
  </div>
  <div class="k">Root package</div>
  <div>
    <code class="inline">{framework.basePackage}</code> =
    <code class="inline">com.endava.ai</code>
  </div>
  <div class="k">Config unificată</div>
  <div>
    <code class="inline">framework.properties</code>
    (<code class="inline">src/main/resources</code>)
  </div>
  <div class="k">Model de interacțiune</div>
  <div>
    <span class="pill">UI</span>
    UIActions + WaitUtils + UIEngine (Selenium | Playwright)
  </div>
  <div class="k">Model de apel</div>
  <div>
    <span class="pill">API</span>
    ApiClient + Services + Validations (TestNG orchestration only)
  </div>
  <div class="k">Reporting unificat</div>
  <div>
    <code class="inline">ReportLogger</code> +
    <code class="inline">ReportingManager</code> +
    <code class="inline">StepLogger</code>
  </div>
  <div class="k">Reporting engines</div>
  <div>
    <code class="inline">Extent</code> ·
    <code class="inline">Allure</code>
    <span class="muted">(+ viitoare adaptoare)</span>
  </div>
  <div class="k">Reutilizare reporting (API)</div>
  <div>
    <span class="pill">reporting.mode = shared | local</span>
    <span class="muted">
      (shared → reutilizează componentele de reporting din pachetele core;
       local → inițializează reporting separat)
    </span>
  </div>
</div>
<hr class="sep"/>
<details>
  <summary>Structură canonică de pachete</summary>
  <ul>
    <li><b>MUST</b> toate componentele framework-ului să fie definite sub același <code class="inline">{framework.basePackage}</code> și în același <code class="inline">src</code>.</li>   <li>UI root package: <code class="inline">{framework.basePackage}.ui</code></li>
    <li>API root package: <code class="inline">{framework.basePackage}.api</code></li>
    <li>Core module: <code class="inline">{framework.basePackage}.core</code></li>
    <li>Reporting module: <code class="inline">{framework.basePackage}.core.reporting</code></li>
  </ul>
  <details>
    <summary>Ierarhie folosită <span class="sumhint">core / config / reporting</span></summary>
    <span class="pill">Core module</span>
    <pre><code>│   TestListener.java
│
├───config
│       ConfigManager.java
│
└───reporting
    │   ReportingManager.java
    │   ReportLogger.java
    │   StepLogger.java
    │
    └───adapters
            AllureAdapter.java
            ExtentAdapter.java</code></pre>
  </details>
</details>
<div class="split">
</div>
</div>
<div class="card">
<h2>Configurație centralizată</h2>
<div class="note">
    Valorile de configurare sunt gestionate într-un singur punct și accesate exclusiv prin <b>ConfigManager</b>.
   </div>
<details open="">
<summary>UI — proprietăți <span class="sumhint">framework.properties</span></summary>
<pre><code>base.url=https://practicesoftwaretesting.com
ui.engine=selenium      # selenium | Playwright
reports.dir=reports
reporting.engine=extent   # extent | allure
explicit.wait.seconds=2
reports.timestamp.enabled=true
reports.timestamp.format=yyyy-MM-dd_HH-mm-ss
console.details.enabled=true
allure.results.dir=allure-results  # obligatoriu dacă reporting.engine=allure</code></pre>
</details>
<details open="">
<summary>API — proprietăți <span class="sumhint">framework.properties</span></summary>
<pre><code>base.url.api=https://gorest.co.in
reports.dir=reports
reporting.mode=shared    # shared | local
reporting.engine=extent   # compatibil cu modulul de reporting reutilizat
reports.timestamp.enabled=true
reports.timestamp.format=yyyy-MM-dd_HH-mm-ss
console.details.enabled=true # dacă modulul de reporting o suportă</code></pre>
</details>
</div>
</div>
<hr class="sep"/>
<div class="card">
<h2>2) Diagrame de arhitectură</h2>
<details open=""><summary>2.1 Structura modulelor și fluxurile principale (UI + API)</summary><details><summary>2.1.1 Structura modulelor (static) <span class="sumhint">component</span></summary><div class="card">
<div class="diag">
<svg aria-label="Structura modulelor (static)" height="380" viewbox="0 0 980 380" width="980">
<!-- frames -->
<rect fill="#0b1220" height="320" rx="14" stroke="#334" width="300" x="20" y="30"></rect>
<text fill="#9ddcff" font-size="14" x="38" y="58">UI Module</text>
<rect fill="#0b1220" height="320" rx="14" stroke="#334" width="300" x="340" y="30"></rect>
<text fill="#9ddcff" font-size="14" x="358" y="58">API Module</text>
<rect fill="#0b1220" height="320" rx="14" stroke="#334" width="300" x="660" y="30"></rect>
<text fill="#9ddcff" font-size="14" x="678" y="58">Reporting</text>
<!-- nodes (preview v0.9 style) -->
<!-- UI column -->
<rect fill="#1e293b" height="60" rx="8" width="240" x="50" y="90"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="170" y="126">Tests</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="50" y="168"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="170" y="204">Services</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="50" y="246"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="170" y="282">UIActions</text>
<!-- UI arrows -->
<line stroke="#93c5fd" stroke-width="2" x1="170" x2="170" y1="150" y2="168"></line>
<polyline fill="none" points="166,162 170,168 174,162" stroke="#93c5fd" stroke-width="2"></polyline>
<line stroke="#93c5fd" stroke-width="2" x1="170" x2="170" y1="228" y2="246"></line>
<polyline fill="none" points="166,240 170,246 174,240" stroke="#93c5fd" stroke-width="2"></polyline>
<!-- API column -->
<rect fill="#1e293b" height="60" rx="8" width="240" x="370" y="90"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="490" y="126">Tests</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="370" y="168"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="490" y="204">Services</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="370" y="246"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="490" y="282">Validation</text>
<line stroke="#93c5fd" stroke-width="2" x1="490" x2="490" y1="150" y2="168"></line>
<polyline fill="none" points="486,162 490,168 494,162" stroke="#93c5fd" stroke-width="2"></polyline>
<line stroke="#93c5fd" stroke-width="2" x1="490" x2="490" y1="228" y2="246"></line>
<polyline fill="none" points="486,240 490,246 494,240" stroke="#93c5fd" stroke-width="2"></polyline>
<!-- Reporting column -->
<rect fill="#1e293b" height="60" rx="8" width="240" x="690" y="90"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="810" y="126">TestListener</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="690" y="168"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="810" y="204">StepLogger</text>
<rect fill="#1e293b" height="60" rx="8" width="240" x="690" y="246"></rect>
<text fill="#e6e9ef" text-anchor="middle" x="810" y="282">ReportingMgr → ReportLogger → Adapters</text>
<!-- Reporting arrows -->
<line stroke="#93c5fd" stroke-width="2" x1="810" x2="810" y1="150" y2="168"></line>
<polyline fill="none" points="806,162 810,168 814,162" stroke="#93c5fd" stroke-width="2"></polyline>
<line stroke="#93c5fd" stroke-width="2" x1="810" x2="810" y1="228" y2="246"></line>
<polyline fill="none" points="806,240 810,246 814,240" stroke="#93c5fd" stroke-width="2"></polyline>
</svg>
<details>
<summary>Explicație <span class="sumhint">structură și responsabilități</span></summary>
<h4>Ce ilustrează:</h4>
<ul>
  <li><b>Separarea responsabilităților</b> între componentele UI, API și Reporting, cu testele limitate strict la orchestrare.</li>
  <li><b>UI</b>: interacțiunile, așteptările și validările sunt izolate de teste și grupate în layere dedicate.</li>
  <li><b>API</b>: apelurile HTTP și aserțiunile sunt separate de testele de orchestrare prin Services și Validation.</li>
  <li><b>Reporting</b>: lifecycle-ul testului și semantica pașilor sunt centralizate și independente de engine-urile UI/API.</li>
</ul>
<h4>De ce este important:</h4>
<ul>
<li>Permite schimbarea engine-urilor UI, API sau de raportare fără impact asupra testelor.</li>
<li>Reduce cuplarea și duplicarea logicii între module.</li>
<li>Asigură un model unitar și predictibil pentru testare și raportare.</li>
</ul>
</details>
</div>
</div></details><details><summary>2.1.2 Flux UI → Reporting <span class="sumhint">sequence</span></summary><div class="card">
<p class="muted">Fluxul arată cum acțiunile UI devin pași în raport și cum sunt rutate către engine-ul de reporting prin abstractions.</p>
<div class="diag">
<svg aria-label="Flux UI → Reporting" height="250" viewbox="0 0 980 250" width="980">
<defs>
<marker id="arrow" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
</defs>
<!-- -->
<text fill="#a8b3cf" font-size="12" x="40" y="44"></text>
<rect fill="#1e293b" height="44" rx="10" width="150" x="40" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="115" y="88">Tests</text>
<rect fill="#1e293b" height="44" rx="10" width="170" x="220" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="305" y="88">Services</text>
<rect fill="#1e293b" height="44" rx="10" width="170" x="420" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="505" y="88">UIActions</text>
<!-- lane -->
<text fill="#a8b3cf" font-size="12" x="40" y="142"></text>
<rect fill="#1e293b" height="44" rx="10" width="170" x="420" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="505" y="186">StepLogger</text>
<rect fill="#1e293b" height="44" rx="10" width="170" x="610" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="695" y="186">ReportingMgr</text>
<rect fill="#1e293b" height="44" rx="10" width="160" x="800" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="880" y="186">ReportLogger</text>
<rect fill="#1e293b" height="34" rx="10" width="160" x="800" y="210"></rect>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="880" y="232">Extent | Allure</text>
<!-- Arrows (no crossings) -->
<line marker-end="url(#arrow)" stroke="#93c5fd" stroke-width="2" x1="190" x2="220" y1="82" y2="82"></line>
<line marker-end="url(#arrow)" stroke="#93c5fd" stroke-width="2" x1="390" x2="420" y1="82" y2="82"></line>
<!-- Drop to StepLogger -->
<path d="M505 104 C505 122, 505 130, 505 158" fill="none" marker-end="url(#arrow)" stroke="#6ee7b7" stroke-width="2"></path>
<text fill="#a7f3d0" font-size="11" x="520" y="132">step semantics</text>
<line marker-end="url(#arrow)" stroke="#93c5fd" stroke-width="2" x1="590" x2="610" y1="180" y2="180"></line>
<line marker-end="url(#arrow)" stroke="#93c5fd" stroke-width="2" x1="780" x2="800" y1="180" y2="180"></line>
<path d="M880 202 C880 206, 880 206, 880 210" fill="none" marker-end="url(#arrow)" stroke="#93c5fd" stroke-width="2"></path>
</svg>
<details>
<summary>Explicație <span class="sumhint">transformarea acțiunilor ui în pași raportați</span></summary>
<ul>
<li><b>Ce ilustrează:</b> Transformarea unei acțiuni UI într-un pas semantic raportat.</li>
<li><b>Tests:</b> Declanșează acțiuni de nivel înalt, independent de engine-ul UI folosit (Selenium, Playwright).</li>
<li><b>UIActions:</b> Decide dacă este necesar un wait și execută acțiunea prin engine.</li>
<li><b>StepLogger:</b> Creează pasul, loghează detalii și controlează PASS/FAIL.</li>
<li><b>ReportingManager:</b> Selectează adapterul de raportare (Extent / Allure).</li>
<li><b>Regulă cheie:</b> Fiecare pas poate avea un singur FAIL; engine-ul și testele nu fac logging direct.</li>
</ul>
</details>
</div>
</div></details><details><summary>2.1.3 Flux API → Reporting <span class="sumhint">sequence</span></summary><div class="card">
<p class="muted">Flux simetric: apelurile HTTP și validările devin pași în raport prin același contract (StepLogger → ReportingManager → ReportLogger).</p>
<div class="diag">
<svg aria-label="Flux API → Reporting" height="250" viewbox="0 0 980 250" width="980">
<defs>
<marker id="arrow2" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
</defs>
<!-- -->
<text fill="#a8b3cf" font-size="12" x="40" y="44"></text>
<rect fill="#1e293b" height="44" rx="10" width="150" x="40" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="115" y="88">Tests</text>
<rect fill="#1e293b" height="44" rx="10" width="180" x="220" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="310" y="88">Services</text>
<rect fill="#1e293b" height="44" rx="10" width="180" x="430" y="60"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="520" y="88">Validation</text>
<!-- lane -->
<text fill="#a8b3cf" font-size="12" x="40" y="142"></text>
<rect fill="#1e293b" height="44" rx="10" width="180" x="430" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="520" y="186">StepLogger</text>
<rect fill="#1e293b" height="44" rx="10" width="170" x="630" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="715" y="186">ReportingMgr</text>
<rect fill="#1e293b" height="44" rx="10" width="140" x="820" y="158"></rect>
<text fill="#e6e9ef" font-size="13" text-anchor="middle" x="890" y="186">ReportLogger</text>
<rect fill="#1e293b" height="34" rx="10" width="140" x="820" y="210"></rect>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="890" y="232">Extent | Allure</text>
<!-- Arrows (no crossings) -->
<line marker-end="url(#arrow2)" stroke="#93c5fd" stroke-width="2" x1="190" x2="220" y1="82" y2="82"></line>
<line marker-end="url(#arrow2)" stroke="#93c5fd" stroke-width="2" x1="400" x2="430" y1="82" y2="82"></line>
<!-- Drop to StepLogger -->
<path d="M520 104 C520 122, 520 130, 520 158" fill="none" marker-end="url(#arrow2)" stroke="#6ee7b7" stroke-width="2"></path>
<text fill="#a7f3d0" font-size="11" x="538" y="132">step semantics</text>
<line marker-end="url(#arrow2)" stroke="#93c5fd" stroke-width="2" x1="610" x2="630" y1="180" y2="180"></line>
<line marker-end="url(#arrow2)" stroke="#93c5fd" stroke-width="2" x1="800" x2="820" y1="180" y2="180"></line>
<path d="M890 202 C890 206, 890 206, 890 210" fill="none" marker-end="url(#arrow2)" stroke="#93c5fd" stroke-width="2"></path>
</svg>
<details>
<summary>Explicație <span class="sumhint">raportare unificată pentru api</span></summary>
<ul>
<li><b>Ce ilustrează:</b> Transformarea apelurilor HTTP și a validărilor în pași raportați.</li>
<li><b>Services:</b> Execută apelurile HTTP prin ApiClient.</li>
<li><b>Validation:</b> Rulează aserțiunile exclusiv în pași logați.</li>
<li><b>StepLogger:</b> Asigură o semantică de logging unitară.</li>
<li><b>Beneficiu:</b> Toate testele folosesc același model de raportare.</li>
</ul>
</details>
</div>
</div></details></details>
<details>
<summary>2.2 Flux TestNG + StepLogger (reguli de eșec) <span class="sumhint">sequence</span></summary>
<div class="diag">
<!-- SVG: sequence diagram (style aligned to preview) -->
<svg aria-label="TestNG + StepLogger flow" height="420" viewbox="0 0 980 420" width="980">
<defs>
<marker id="arrow2" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
<marker id="arrowFail" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#f87171"></path>
</marker>
</defs>
<!-- lifeline labels -->
<text fill="#9ddcff" font-size="14" x="90" y="34">TestNG</text>
<text fill="#9ddcff" font-size="14" x="270" y="34">TestListener</text>
<text fill="#9ddcff" font-size="14" x="470" y="34">StepLogger</text>
<text fill="#9ddcff" font-size="14" x="650" y="34">ReportingManager</text>
<text fill="#9ddcff" font-size="14" x="840" y="34">ReportLogger</text>
<!-- lifelines -->
<line stroke="#334" x1="90" x2="90" y1="54" y2="390"></line>
<line stroke="#334" x1="270" x2="270" y1="54" y2="390"></line>
<line stroke="#334" x1="470" x2="470" y1="54" y2="390"></line>
<line stroke="#334" x1="650" x2="650" y1="54" y2="390"></line>
<line stroke="#334" x1="840" x2="840" y1="54" y2="390"></line>
<!-- messages -->
<line stroke="#93c5fd" stroke-width="2" x1="90" x2="270" y1="92" y2="92"></line><polygon fill="#93c5fd" points="270.00,92.00 260.00,98.00 260.00,86.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="180" y="82">onTestStart()</text>
<line stroke="#93c5fd" stroke-width="2" x1="270" x2="650" y1="130" y2="130"></line><polygon fill="#93c5fd" points="650.00,130.00 640.00,136.00 640.00,124.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="460" y="120">getLogger()</text>
<line stroke="#93c5fd" stroke-width="2" x1="650" x2="840" y1="160" y2="160"></line><polygon fill="#93c5fd" points="840.00,160.00 830.00,166.00 830.00,154.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="745" y="150">resolve by reporting.engine</text>
<line stroke="#93c5fd" stroke-width="2" x1="270" x2="840" y1="196" y2="196"></line><polygon fill="#93c5fd" points="840.00,196.00 830.00,202.00 830.00,190.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="555" y="186">startTest(name, desc)</text>
<line stroke="#93c5fd" stroke-width="2" x1="270" x2="470" y1="228" y2="228"></line><polygon fill="#93c5fd" points="470.00,228.00 460.00,234.00 460.00,222.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="370" y="218">markTestStarted()</text>
<line stroke="#93c5fd" stroke-width="2" x1="90" x2="470" y1="266" y2="266"></line><polygon fill="#93c5fd" points="470.00,266.00 460.00,272.00 460.00,260.00" stroke="#93c5fd" stroke-width="2"></polygon>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="280" y="256">startStep(title) / logDetail(...)</text>
<line stroke="#f87171" stroke-width="2" x1="470" x2="840" y1="298" y2="298"></line><polygon fill="#f87171" points="840.00,298.00 830.00,304.00 830.00,292.00" stroke="#f87171" stroke-width="2"></polygon>
<text fill="#fca5a5" font-size="12" text-anchor="middle" x="655" y="288">fail(msg, stacktraceText) (o singură dată)</text>
</svg>
<details>
<summary>Explicație <span class="sumhint">lifecycle test și reguli de eșec</span></summary>
<ul>
<li><b>Ce ilustrează:</b> Separarea responsabilităților dintre lifecycle-ul testului și semantica pașilor raportați.</li>
<li><b>Separarea responsabilităților:</b>
<ul>
<li><b>TestListener:</b> gestionează începutul și sfârșitul testului (evenimente TestNG) și creează/închide contextul de raportare la nivel de test.</li>
<li><b>StepLogger:</b> definește pasul semantic și controlează raportarea corectă, fiind singurul care poate emite FAIL într-un pas.</li>
</ul>
</li>
<li><b>Reguli implicite ale diagramei:</b>
<ul>
<li>Un singur FAIL per pas.</li>
<li>Detaliile se loghează doar în interiorul unui pas.</li>
<li>Excepțiile apărute în afara pașilor produc FAIL la nivel de test.</li>
<li><b>Interdicție:</b> <code class="inline">StepLogger.logDetail(...)</code> în afara unui step activ.</li>
</ul>
</li>
</ul>
</details>
</div>
</details>
<details>
<summary>2.3 Lifecycle TestNG + reporting (UI) <span class="sumhint">sequence</span></summary>
<div class="diag">
<svg aria-label="UI lifecycle with screenshot" height="420" viewbox="0 0 980 420" width="980">
<defs>
<marker id="arrow3" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
</defs>
<text fill="#9ddcff" font-size="14" x="70" y="34">TestNG</text>
<text fill="#9ddcff" font-size="14" x="220" y="34">TestListener</text>
<text fill="#9ddcff" font-size="14" x="400" y="34">StepLogger</text>
<text fill="#9ddcff" font-size="14" x="580" y="34">ReportingManager</text>
<text fill="#9ddcff" font-size="14" x="770" y="34">ReportLogger</text>
<text fill="#9ddcff" font-size="14" x="910" y="34">Driver</text>
<line stroke="#334" x1="70" x2="70" y1="54" y2="390"></line>
<line stroke="#334" x1="220" x2="220" y1="54" y2="390"></line>
<line stroke="#334" x1="400" x2="400" y1="54" y2="390"></line>
<line stroke="#334" x1="580" x2="580" y1="54" y2="390"></line>
<line stroke="#334" x1="770" x2="770" y1="54" y2="390"></line>
<line stroke="#334" x1="910" x2="910" y1="54" y2="390"></line>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="70" x2="220" y1="90" y2="90"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="145" y="80">onTestStart()</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="580" y1="120" y2="120"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="400" y="110">getLogger()</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="770" y1="150" y2="150"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="495" y="140">startTest(name, desc)</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="400" y1="180" y2="180"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="310" y="170">markTestStarted()</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="70" x2="400" y1="220" y2="220"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="235" y="210">startStep / logDetail / pass</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="70" x2="220" y1="270" y2="270"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="145" y="260">onTestFailure()</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="910" y1="300" y2="300"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="565" y="290">captureScreenshotAsBase64()</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="770" y1="332" y2="332"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="495" y="322">attachScreenshotBase64(base64, title) (TEST-level)</text>
<line marker-end="url(#arrow3)" stroke="#93c5fd" stroke-width="2" x1="220" x2="770" y1="362" y2="362"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="495" y="352">endTest(FAIL) + clearTestStarted()</text>
</svg>
<details>
<summary>Explicație <span class="sumhint">screenshot și eșec ui</span></summary>
<ul>
<li><b>Ce ilustrează:</b> separarea clară a responsabilităților dintre lifecycle-ul testului și pașii raportați.</li>
<li><b>Roluri:</b>
<ul>
<li><b>TestListener</b> controlează lifecycle-ul testului și gestionează screenshot-ul la FAIL.</li>
<li><b>StepLogger</b> creează pașii și este singurul care poate emite FAIL la nivel de pas.</li>
<li><b>ReportingManager</b> selectează adapterul de raportare.</li>
<li><b>Driver</b> (via DriverManager/UIEngine) furnizează screenshot Base64, fără a expune detalii de engine.</li>
</ul>
</li>
<li><b>Reguli cheie:</b>
<ul>
<li>Screenshot: un singur atașament per test FAIL, la nivel de test.</li>
<li>Stacktrace: doar în pasul care a eșuat.</li>
<li>StepLogger: un singur FAIL per pas; fără logging în afara pașilor.</li>
<li><b>Notă de integrare:</b> pentru Allure, ordinea listener-ilor este critică; atașamentele trebuie adăugate înainte de închiderea testului.</li>
</ul>
</li>
</ul>
</details>
</div>
</details>
<details>
<summary>2.4 Lifecycle TestNG + reporting (API) <span class="sumhint">sequence</span></summary>
<div class="diag">
<svg aria-label="API shared reporting lifecycle" height="400" viewbox="0 0 980 400" width="980">
<defs>
<marker id="arrow4" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
</defs>
<text fill="#9ddcff" font-size="14" x="70" y="34">TestNG</text>
<text fill="#9ddcff" font-size="14" x="220" y="34">Listener</text>
<text fill="#9ddcff" font-size="14" x="360" y="34">Services</text>
<text fill="#9ddcff" font-size="14" x="520" y="34">Validation</text>
<text fill="#9ddcff" font-size="14" x="700" y="34">StepLogger</text>
<text fill="#9ddcff" font-size="14" x="860" y="34">ReportLogger</text>
<line stroke="#334" x1="70" x2="70" y1="54" y2="370"></line>
<line stroke="#334" x1="220" x2="220" y1="54" y2="370"></line>
<line stroke="#334" x1="360" x2="360" y1="54" y2="370"></line>
<line stroke="#334" x1="520" x2="520" y1="54" y2="370"></line>
<line stroke="#334" x1="700" x2="700" y1="54" y2="370"></line>
<line stroke="#334" x1="860" x2="860" y1="54" y2="370"></line>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="70" x2="220" y1="92" y2="92"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="145" y="82">onTestStart()</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="220" x2="860" y1="124" y2="124"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="540" y="114">startTest(...)</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="220" x2="700" y1="156" y2="156"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="460" y="146">markTestStarted()</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="70" x2="360" y1="200" y2="200"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="215" y="190">call flow</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="360" x2="700" y1="232" y2="232"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="530" y="222">startStep("HTTP ...") + logDetail(...)</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="360" x2="860" y1="264" y2="264"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="610" y="254">logCodeBlock(payload) (via ReportingManager.getLogger())</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="70" x2="520" y1="304" y2="304"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="295" y="294">assertions</text>
<line marker-end="url(#arrow4)" stroke="#93c5fd" stroke-width="2" x1="520" x2="700" y1="336" y2="336"></line>
<text fill="#e6e9ef" font-size="12" text-anchor="middle" x="610" y="326">startStep("Validate ...") + pass/fail (single)</text>
</svg>
<details>
<summary>Explicație <span class="sumhint">api cu reporting partajat</span></summary>
<ul>
<li><b>Ce ilustrează:</b> execuția unui test API cu mecanism de reporting reutilizat.</li>
<li><b>Pași în testele API:</b>
<ul>
<li><b>Services</b> execută request-uri HTTP și creează pași HTTP …, cu metoda, path-ul, URL-ul și parametrii relevanți.</li>
<li><b>Payload-uri</b> (request/response) sunt atașate ca code block în raport.</li>
<li><b>Validations</b> rulează aserțiuni în pași separați, distinct de pașii de apel HTTP.</li>
</ul>
</li>
</ul>
</details>
</div>
</details>
<details>
<summary>2.5 Structura nodurilor în raport <span class="sumhint">ux model</span></summary>
<div class="diag">
<svg aria-label="Report node structure" height="300" viewbox="0 0 980 300" width="980">
<defs>
<marker id="arrow5" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="9" refy="3">
<path d="M0,0 L10,3 L0,6 z" fill="#93c5fd"></path>
</marker>
</defs>
<rect fill="#1e293b" height="46" rx="10" width="200" x="40" y="40"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="140" y="69">Test Node</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="540" y="40"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="640" y="69">Screenshot (FAIL)</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="40" y="130"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="140" y="159">Step Node (collapsible)</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="290" y="130"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="390" y="159">Details</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="540" y="130"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="640" y="159">Payloads (code)</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="290" y="220"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="390" y="249">PASS / FAIL</text>
<rect fill="#1e293b" height="46" rx="10" width="200" x="540" y="220"></rect><text fill="#e6e9ef" font-size="13" text-anchor="middle" x="640" y="249">Stacktrace (step only)</text>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="240" x2="540" y1="63" y2="63"></line>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="140" x2="140" y1="86" y2="130"></line>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="240" x2="290" y1="153" y2="153"></line>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="490" x2="540" y1="153" y2="153"></line>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="390" x2="390" y1="176" y2="220"></line>
<line marker-end="url(#arrow5)" stroke="#93c5fd" stroke-width="2" x1="490" x2="540" y1="243" y2="243"></line>
</svg>
<details>
<summary>Explicație <span class="sumhint">model ux al raportului</span></summary>
<ul>
<li><b>Ce ilustrează:</b> definește “contractul UX” al raportului: unde se pune fiecare categorie de informație, ca raportul să fie <i>scanabil</i> și fără duplicări.</li>
<li><b>Test Node:</b>
<ul>
<li><b>Conține:</b> nume test, descriere, timp de execuție, status final (PASS/FAIL/SKIP) etc.</li>
<li><b>NU conține:</b> stacktrace, payload-uri, detalii de pas. </li>
</ul>
</li>
<li><b>Step Node:</b>
<ul>
<li><b>Titlu semantic:</b> arată acțiunea/intenția (ex. “Click on: Register”, “HTTP POST /users”, “Validate: status 201”).</li>
<li><b>Details:</b> scurte și standardizate, suficiente pentru a înțelege ce s-a executat.</li>
<li><b>Payloads/stacktrace:</b> doar ca <b>code blocks</b> pentru lizibilitate.</li>
<li><b>Rezultat:</b> PASS/FAIL la nivel de step.</li>
</ul>
</li>
<div class="rule">
<b>Set minim de detalii recomandate (standardizare):</b>
<div class="split">
<div class="mini">
<h3>UI step — details</h3>
<ul>
<li><code class="inline">locator=cssSelector</code></li>
<li><code class="inline">value=...</code> (pentru type/select)</li>
<li><code class="inline">wait=visible/clickable</code> (dacă s-a aplicat explicit)</li>
</ul>
</div>
<div class="mini">
<h3>API step — details</h3>
<ul>
<li><code class="inline">method=POST</code>, <code class="inline">path=/public/v2/users</code></li>
<li><code class="inline">url=https://.../public/v2/users</code></li>
<li><code class="inline">status=201</code> (după primirea răspunsului)</li>
</ul>
</div>
</div>
</div>
</ul></details>
</div>
<div class="rule">
<b>Regulă de aur:</b> stacktrace-ul apare o singură dată, numai în step-ul care a picat. Test node-ul nu primește stacktrace.
   </div>
</details>
</div>
<hr class="sep"/>
<div class="card">
<h2>3) Reguli canonice (UI + API) — MUST / MUST NOT</h2><details>
  <summary>3.0 Implementare canonică &amp; reutilizare <span class="sumhint">referință canonică</span></summary>
  <div class="note">
   <ul>
    <li>
    <b>Scop:</b> această secțiune reduce riscul de „spec drift”. </li>
	<li>Regulile <b>MUST/MUST NOT</b> descriu arhitectura.</li>
	<li><b>implementarea canonică</b> de mai jos este referința practică pentru comportamentul exact al raportării
    (mai ales pentru lifecycle + atașamente).</li>
	</ul>
  </div>

  <h4>Delimitare clară</h4>
  <ul>
    <li><b>Regulă arhitecturală</b> = o constrângere care trebuie respectată indiferent de implementare.</li>
    <li><b>Implementare canonică</b> = codul concret folosit ca baseline; dacă apar divergențe, codul canonic câștigă (până la actualizarea spec-ului).</li>
  </ul>

  <h4>Reutilizare (fără duplicare)</h4>
  <ul>
    <li><b>MUST</b> componentele de reporting din <code class="inline">core</code> să poată fi reutilizate identic în UI și API.</li>
    <li><b>MUST</b> orice proiect generat să includă aceste clase ca artefact „canonical”, fie prin copiere 1:1, fie ca modul intern (dar fără Maven multi-module; rămâne un singur <code class="inline">pom.xml</code>).</li>
  </ul>

  <details>
    <summary>Canonical classes <span class="sumhint">embedding pentru reconstrucție</span></summary>
    <div class="warn">
	<ul>
	<li>Dacă refaci framework-ul pe baza acestui document, tratează următoarele clase ca <b>autoritative</b> pentru reporting.</li>
    <li>Regulă: nu modifica semantica fără să actualizezi și secțiunile MUST/MUST NOT aferente.</li>
	</ul>
    </div>
    <details>
  <summary>main.java.com.endava.ai.core.TestListener.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core;

import com.endava.ai.core.config.ConfigManager;
import com.endava.ai.core.reporting.ReportingManager;
import com.endava.ai.core.reporting.StepLogger;
import com.endava.ai.ui.core.DriverManager;
import org.testng.ISuite;
import org.testng.ISuiteListener;
import org.testng.ITestListener;
import org.testng.ITestResult;

import java.util.concurrent.atomic.AtomicBoolean;

public final class TestListener implements ITestListener, ISuiteListener {

    private final ThreadLocal&lt;AtomicBoolean&gt; screenshotTaken =
            ThreadLocal.withInitial(() -&gt; new AtomicBoolean(false));

    private boolean useExtent() {
        return !&quot;allure&quot;.equalsIgnoreCase(
                ConfigManager.get(&quot;reporting.engine&quot;, &quot;extent&quot;)
        );
    }

    @Override
    public void onStart(ISuite suite) {
        if (useExtent()) ReportingManager.getLogger();
    }

    @Override
    public void onFinish(ISuite suite) {
        if (useExtent()) ReportingManager.getLogger().flush();
    }

    @Override
    public void onTestStart(ITestResult result) {
        if (useExtent()) {
            ReportingManager.getLogger().startTest(
                    result.getMethod().getMethodName(),
                    result.getMethod().getDescription()
            );
        }
        StepLogger.markTestStarted();
        screenshotTaken.get().set(false);
    }

    @Override
    public void onTestSuccess(ITestResult result) {
        endTest(&quot;PASS&quot;);
    }

    @Override
    public void onTestSkipped(ITestResult result) {
        endTest(&quot;SKIP&quot;);
    }

    @Override
    public void onTestFailure(ITestResult result) {
        try {
            if (!StepLogger.testHasFailed()) {
                StepLogger.failUnhandledOutsideStep(result.getThrowable());
            }
            attachScreenshotOnce();
        } finally {
            endTest(&quot;FAIL&quot;);
        }
    }

    @Override
    public void onTestFailedWithTimeout(ITestResult result) {
        onTestFailure(result);
    }

    @Override
    public void onTestFailedButWithinSuccessPercentage(ITestResult result) {
    }

    private void endTest(String status) {
        if (useExtent()) ReportingManager.getLogger().endTest(status);
        StepLogger.clearTestStarted();
    }

    private void attachScreenshotOnce() {
        if (!screenshotTaken.get().getAndSet(true) &amp;&amp; DriverManager.hasActiveEngine()) {
            String base64 = DriverManager.getEngine().captureScreenshotAsBase64();
            ReportingManager.getLogger().attachScreenshotBase64(base64, &quot;Failure Screenshot&quot;);
        }
    }
}</code></pre>
</details><details>
  <summary>main.java.com.endava.ai.core.reporting.ReportLogger.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core.reporting;

public interface ReportLogger {
    void startTest(String testName, String description);
    void endTest(String status);            // PASS, FAIL, SKIP
    void startStep(String stepTitle);
    void logDetail(String detail);
    void pass(String message);
    void fail(String message, String stacktraceAsText);
    void attachScreenshotBase64(String base64, String title);
    void logCodeBlock(String content);
    void flush();
}</code></pre>
</details><details>
  <summary>main.java.com.endava.ai.core.reporting.ReportingManager.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core.reporting;

import com.endava.ai.core.config.ConfigManager;
import com.endava.ai.core.reporting.adapters.AllureAdapter;
import com.endava.ai.core.reporting.adapters.ExtentAdapter;

import java.util.Locale;

public final class ReportingManager {

    private static volatile ReportLogger logger;

    private ReportingManager() {}

    public static ReportLogger getLogger() {
        ReportLogger result = logger;
        if (result != null) return result;

        synchronized (ReportingManager.class) {
            if (logger == null) {
                logger = createLogger();
            }
            return logger;
        }
    }

    private static ReportLogger createLogger() {
        String engine = ConfigManager.require(&quot;reporting.engine&quot;)
                .trim()
                .toLowerCase(Locale.ROOT);
        switch (engine) {
            case &quot;extent&quot;:
                return ExtentAdapter.getInstance();
            case &quot;allure&quot;:
                return AllureAdapter.getInstance();
            default:
                throw new IllegalArgumentException(
                        &quot;Unsupported reporting.engine: &quot; + engine +
                                &quot; (supported: extent, allure)&quot;
                );
        }
    }
}</code></pre>
</details><details>
  <summary>main.java.com.endava.ai.core.reporting.StepLogger.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core.reporting;

import com.endava.ai.core.config.ConfigManager;

public final class StepLogger {

    private static final ThreadLocal&lt;StepState&gt; STATE = new ThreadLocal&lt;&gt;();
    private static final ThreadLocal&lt;Boolean&gt; TEST_STARTED = new ThreadLocal&lt;&gt;();
    private static final ThreadLocal&lt;Boolean&gt; TEST_FAILED = new ThreadLocal&lt;&gt;();

    private static final int MAX_EXTERNAL_FRAMES = 3;
    private static final String INTERNAL_PACKAGE = &quot;com.endava&quot;;

    private StepLogger() {}

    public static void markTestStarted() {
        TEST_STARTED.set(Boolean.TRUE);
        TEST_FAILED.set(Boolean.FALSE);
    }

    public static void clearTestStarted() {
        TEST_STARTED.remove();
        STATE.remove();
        TEST_FAILED.remove();
    }

    public static boolean testHasFailed() {
        return Boolean.TRUE.equals(TEST_FAILED.get());
    }

    public static void startStep(String title) {
        requireTestStarted();
        ReportingManager.getLogger().startStep(title);
        STATE.set(StepState.STARTED);
        console(&quot;▶ &quot; + title);
    }

    public static void logDetail(String detail) {
        requireActiveStep();
        ReportingManager.getLogger().logDetail(detail);

        if (ConfigManager.getBoolean(&quot;console.details.enabled&quot;)) {
            console(&quot;  • &quot; + detail);
        }
    }

    public static void pass(String message) {
        requireActiveStep();
        if (STATE.get() == StepState.FAILED) return;

        ReportingManager.getLogger().pass(message);
        STATE.set(StepState.PASSED);
        console(&quot;  ✅ PASS: &quot; + message);
        STATE.remove();
    }

    public static void fail(String message, Throwable t) {
        fail(message, formatStacktrace(t));
    }

    public static void fail(String message, String stacktraceAsText) {
        requireActiveStep();
        if (STATE.get() == StepState.FAILED) return;

        TEST_FAILED.set(Boolean.TRUE);

        ReportingManager.getLogger().logDetail(message);
        ReportingManager.getLogger().fail(message, stacktraceAsText);
        STATE.set(StepState.FAILED);
        console(&quot;  ❌ FAIL: &quot; + message);
        STATE.remove();
    }

    public static void failUnhandledOutsideStep(Throwable t) {
        if (testHasFailed()) return;

        startStep(&quot;Unhandled exception outside step&quot;);
        fail(&quot;Unhandled exception outside step&quot;, t);
    }

    private static void requireTestStarted() {
        Boolean started = TEST_STARTED.get();
        if (started == null || !started) {
            throw new IllegalStateException(
                    &quot;Test not started. TestListener must start the test before steps run.&quot;
            );
        }
    }

    private static void requireActiveStep() {
        requireTestStarted();
        if (STATE.get() == null) {
            throw new IllegalStateException(
                    &quot;No active step. StepLogger.logDetail/pass/fail must be called within an active step.&quot;
            );
        }
    }

    private static void console(String msg) {
        System.out.println(msg);
    }

    private static String formatStacktrace(Throwable t) {
        if (t == null) return &quot;&quot;;

        Throwable root = findRootCause(t);
        StringBuilder sb = new StringBuilder();

        appendRootMessage(sb, root);
        appendRelevantFrames(sb, root);

        return sb.toString();
    }

    private static Throwable findRootCause(Throwable t) {
        Throwable current = t;
        while (current.getCause() != null &amp;&amp; current.getCause() != current) {
            current = current.getCause();
        }
        return current;
    }

    private static void appendRootMessage(StringBuilder sb, Throwable root) {
        String msg = root.getMessage();
        if (msg == null) return;

        int nl = msg.indexOf(&#x27;\n&#x27;);
        sb.append(nl &gt; 0 ? msg.substring(0, nl) : msg)
                .append(&quot;\n\n&quot;);
    }

    private static void appendRelevantFrames(StringBuilder sb, Throwable root) {
        int externalCount = 0;

        for (StackTraceElement e : root.getStackTrace()) {
            String cls = e.getClassName();

            if (cls.startsWith(INTERNAL_PACKAGE)) {
                sb.append(&quot;at &quot;).append(e).append(&quot;\n&quot;);
                continue;
            }

            if (externalCount &lt; MAX_EXTERNAL_FRAMES) {
                sb.append(&quot;at &quot;).append(e).append(&quot;\n&quot;);
                externalCount++;
            }
        }
    }

    private enum StepState {
        STARTED, PASSED, FAILED
    }
}</code></pre>
</details><details>
  <summary>main.java.com.endava.ai.core.reporting.adapters.AllureAdapter.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core.reporting.adapters;

import com.endava.ai.core.reporting.ReportLogger;
import io.qameta.allure.Allure;
import io.qameta.allure.model.Parameter;
import io.qameta.allure.model.Status;
import io.qameta.allure.model.StepResult;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.UUID;

public final class AllureAdapter implements ReportLogger {

    private static final AllureAdapter INSTANCE = new AllureAdapter();

    private final ThreadLocal&lt;String&gt; currentStepId = new ThreadLocal&lt;&gt;();
    private final ThreadLocal&lt;List&lt;Parameter&gt;&gt; stepParams = ThreadLocal.withInitial(ArrayList::new);

    private AllureAdapter() {}

    public static AllureAdapter getInstance() {
        return INSTANCE;
    }

    @Override
    public void startTest(String testName, String description) {
        // lifecycle managed by allure-testng
    }

    @Override
    public void endTest(String status) {
        currentStepId.remove();
        stepParams.remove();
    }

    @Override
    public void startStep(String stepTitle) {
        String stepId = UUID.randomUUID().toString();
        StepResult step = new StepResult().setName(stepTitle).setStatus(Status.PASSED);

        Allure.getLifecycle().startStep(stepId, step);
        currentStepId.set(stepId);
        stepParams.get().clear();
    }

    @Override
    public void logDetail(String detail) {
        if (detail == null || detail.isBlank()) return;
        stepParams.get().add(new Parameter().setName(&quot;detail&quot;).setValue(detail));
    }

    @Override
    public void pass(String message) {
        String stepId = currentStepId.get();
        if (stepId == null) return;

        List&lt;Parameter&gt; params = stepParams.get();
        Allure.getLifecycle().updateStep(stepId, s -&gt; {
            if (!params.isEmpty()) s.setParameters(new ArrayList&lt;&gt;(params));
            s.setStatus(Status.PASSED);
        });

        Allure.getLifecycle().stopStep(stepId);
        clearStepContext();
    }

    @Override
    public void fail(String message, String stacktraceAsText) {
        String stepId = currentStepId.get();
        if (stepId == null) return;

        List&lt;Parameter&gt; params = stepParams.get();
        if (message != null &amp;&amp; !message.isBlank()) {
            params.add(new Parameter().setName(&quot;error&quot;).setValue(message));
        }

        Allure.getLifecycle().updateStep(stepId, s -&gt; {
            if (!params.isEmpty()) s.setParameters(new ArrayList&lt;&gt;(params));
            s.setStatus(Status.FAILED);
        });

        attachFailureDetails(params, stacktraceAsText);
        Allure.getLifecycle().stopStep(stepId);
        clearStepContext();
    }

    @Override
    public void attachScreenshotBase64(String base64, String title) {
        if (base64 == null || base64.isBlank()) return;

        byte[] bytes = Base64.getDecoder().decode(base64);
        try (InputStream is = new ByteArrayInputStream(bytes)) {
            Allure.addAttachment(
                    title != null ? title : &quot;Failure Screenshot&quot;,
                    &quot;image/png&quot;,
                    is,
                    &quot;.png&quot;
            );
        } catch (Exception ignored) {}
    }

    @Override
    public void logCodeBlock(String content) {
        attachText(&quot;Payload&quot;, &quot;application/json&quot;, &quot;.json&quot;, content);
    }

    @Override
    public void flush() {
        // nothing to flush for Allure
    }

    private void attachFailureDetails(List&lt;Parameter&gt; params, String stacktrace) {
        StringBuilder sb = new StringBuilder();
        for (Parameter p : params) {
            sb.append(p.getName()).append(&#x27;=&#x27;).append(p.getValue()).append(&#x27;\n&#x27;);
        }
        if (stacktrace != null &amp;&amp; !stacktrace.isBlank()) {
            sb.append(&quot;\nSTACKTRACE:\n&quot;).append(stacktrace);
        }
        attachText(&quot;Step failure details&quot;, &quot;text/plain&quot;, &quot;.txt&quot;, sb.toString());
    }

    private void attachText(String name, String mime, String ext, String content) {
        if (content == null) return;

        byte[] bytes = content.getBytes(StandardCharsets.UTF_8);
        try (InputStream is = new ByteArrayInputStream(bytes)) {
            Allure.addAttachment(name, mime, is, ext);
        } catch (Exception ignored) {}
    }

    private void clearStepContext() {
        currentStepId.remove();
        stepParams.get().clear();
    }
}</code></pre>
</details><details>
  <summary>main.java.com.endava.ai.core.reporting.adapters.ExtentAdapter.java <span class="sumhint">canonical code</span></summary>
  <pre><code class="language-java">package com.endava.ai.core.reporting.adapters;

import com.aventstack.extentreports.ExtentReports;
import com.aventstack.extentreports.ExtentTest;
import com.aventstack.extentreports.markuputils.MarkupHelper;
import com.aventstack.extentreports.reporter.ExtentSparkReporter;
import com.aventstack.extentreports.reporter.configuration.Theme;
import com.endava.ai.core.config.ConfigManager;
import com.endava.ai.core.reporting.ReportLogger;

import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.SimpleDateFormat;
import java.util.Date;

public final class ExtentAdapter implements ReportLogger {

    private static final ExtentAdapter INSTANCE = new ExtentAdapter();

    private final ExtentReports extent;
    private final ThreadLocal&lt;ExtentTest&gt; currentTest = new ThreadLocal&lt;&gt;();
    private final ThreadLocal&lt;ExtentTest&gt; currentStep = new ThreadLocal&lt;&gt;();

    private ExtentAdapter() {
        String reportsDir = ConfigManager.require(&quot;reports.dir&quot;);
        boolean tsEnabled = ConfigManager.getBoolean(&quot;reports.timestamp.enabled&quot;);
        String tsFormat = ConfigManager.require(&quot;reports.timestamp.format&quot;);

        String fileName = tsEnabled
                ? &quot;ExtentReport_&quot; + new SimpleDateFormat(tsFormat).format(new Date()) + &quot;.html&quot;
                : &quot;ExtentReport.html&quot;;

        Path reportPath = Paths.get(reportsDir, fileName);

        ExtentSparkReporter spark = new ExtentSparkReporter(reportPath.toString());
        spark.config().setTheme(Theme.DARK);
        spark.config().setDocumentTitle(&quot;UI Test Report&quot;);
        spark.config().setReportName(&quot;UI Test Automation Framework&quot;);
        spark.config().setCss(
                &quot;.card-title a span { color: #f2f2f2 !important; }&quot; +
                        &quot;.card-title a { color: #f2f2f2 !important; }&quot; +
                        &quot;.fa { color: #f2f2f2 !important; }&quot;
        );

        extent = new ExtentReports();
        extent.attachReporter(spark);
    }

    public static ExtentAdapter getInstance() {
        return INSTANCE;
    }

    @Override
    public void startTest(String testName, String description) {
        currentTest.set(extent.createTest(testName, description == null ? &quot;&quot; : description));
        currentStep.remove();
    }

    @Override
    public void endTest(String status) {
        currentStep.remove();
        currentTest.remove();
    }

    @Override
    public void startStep(String stepTitle) {
        currentStep.set(requireTest().createNode(stepTitle));
    }

    @Override
    public void logDetail(String detail) {
        requireStep().info(detail);
    }

    @Override
    public void pass(String message) {
        requireStep().pass(message);
    }

    @Override
    public void fail(String message, String stacktraceAsText) {
        ExtentTest step = requireStep();
        step.fail(message);
        logCodeBlock(stacktraceAsText);
        requireTest().fail(message);
    }

    @Override
    public void attachScreenshotBase64(String base64, String title) {
        requireTest().addScreenCaptureFromBase64String(
                base64,
                title == null ? &quot;Screenshot&quot; : title
        );
    }

    @Override
    public void logCodeBlock(String content) {
        requireStep().info(MarkupHelper.createCodeBlock(content == null ? &quot;&quot; : content));
    }

    @Override
    public void flush() {
        extent.flush();
    }

    private ExtentTest requireTest() {
        ExtentTest t = currentTest.get();
        if (t == null) {
            throw new IllegalStateException(
                    &quot;No active test. TestListener must start the test before steps run.&quot;
            );
        }
        return t;
    }

    private ExtentTest requireStep() {
        ExtentTest s = currentStep.get();
        if (s == null) {
            throw new IllegalStateException(
                    &quot;No active step. StepLogger must start a step before logging details.&quot;
            );
        }
        return s;
    }
}</code></pre>
</details>
  </details>

  <details>
  <summary>Check de consistență (anti-divergență) <span class="sumhint">ghid practic</span></summary>

  <div class="note">
  <ul>
     <li>Această secțiune <b>nu introduce cerințe noi de testare</b>.</li>
     <li>Rolul ei este să facă explicit faptul că anumite teste existente
    validează implicit <b>invarianta de raportare</b> a framework-ului.</li>
	</ul>
  </div>

  <ul>
    <li><b>MUST</b> orice schimbare în reporting lifecycle să fie reflectată în:
      (a) codul canonic,
      (b) regulile 3.1–3.7,
      (c) diagramele relevante (2.2–2.5).</li>

    <li><b>MUST</b> contractul UX din 2.5 să rămână stabil:
      <ul>
        <li>stacktrace apare <b>o singură dată</b>, exclusiv în step-ul <code class="inline">FAIL</code></li>
        <li>screenshot apare <b>o singură dată</b>, la nivel de test <code class="inline">FAIL</code></li>
      </ul>
    </li>
  </ul>

  <div class="rule">
    <b>Observație importantă:</b><br/>
	<ul>
	<li>Nu este necesară scrierea unor teste speciale pentru reporting.</li>
    <li>Framework-ul este validat continuu prin testele existente care eșuează intenționat sau accidental.</li>
	</ul>
  </div>

  <details>
    <summary>Exemple reale de teste care validează reporting-ul <span class="sumhint">din proiect</span></summary>

  <details>
  <summary>1) Excepție în afara unui step</summary>
    <pre><code>▶ Unhandled exception outside step
❌ FAIL: Unhandled exception outside step

java.lang.IllegalStateException: Failed reading resource: testdata/NegativeUserTests_duplicate_email.json
    </code></pre>
    <ul>
      <li>excepția nu este pierdută</li>
      <li>este transformată într-un step explicit</li>
      <li>testul este marcat <code class="inline">FAILED</code>, nu <code class="inline">BROKEN</code></li>
    </ul>
   </details>

   <details>
   <summary>2) Eșec de validare API</summary>
    <pre><code>❌ FAIL: Unexpected HTTP status expected [200] but found [422]</code></pre>
    <ul>
      <li>FAIL apare în step-ul de validare</li>
      <li>stacktrace apare o singură dată</li>
      <li>fluxul de test rămâne lizibil și determinist</li>
    </ul>
  </details>
  
   <details>
   <summary>3) Utilizare greșită a unei UIAction</summary>
    <pre><code>▶ Type into element: Country
❌ FAIL: Failed typing into: Country</code></pre>
    <ul>
      <li>FAIL este localizat în step-ul corect</li>
      <li>mesajul este de nivel framework, nu de engine</li>
      <li>nu există duplicări de stacktrace sau screenshot</li>
    </ul>
   </details>
  </details>

</details>
</details>

<details>
  <summary>3.1 Fundament (config + structură + ownership) <span class="sumhint">architectural rules</span></summary>
  <h4>Config &amp; structură proiect</h4>
  <ul>
    <li><b>MUST</b> toate setările să fie definite în <code class="inline">framework.properties</code>.</li>
    <li><b>MUST</b> accesul la configurație să se facă exclusiv prin <code class="inline">ConfigManager</code>.</li>
    <li><b>MUST</b> exista un singur proiect Maven cu <b>un singur</b> <code class="inline">pom.xml</code> la rădăcină.</li>
  </ul>

  <h4>Ownership lifecycle (pe engine de raportare)</h4>
  <ul>
    <li><b>MUST</b> exista un singur owner al lifecycle-ului de test per engine:
      <code class="inline">TestListener</code> pentru Extent și <code class="inline">AllureTestNg</code> pentru Allure.</li>
    <li><b>MUST NOT</b> <code class="inline">TestListener</code> să controleze lifecycle-ul testului când <code class="inline">reporting.engine=allure</code>.</li>
    <li><b>MUST</b> exista un singur <code class="inline">TestListener</code>, comun UI și API, dar cu logică engine-aware.</li>
  </ul>

  <h4>Separare responsabilități</h4>
  <ul>
    <li><b>MUST</b> componentele de raportare să fie izolate în <code class="inline">{framework.basePackage}.core.reporting</code>.</li>
    <li><b>MUST</b> selecția engine-ului de raportare să fie făcută exclusiv de <code class="inline">ReportingManager</code>.</li>
    <li><b>MUST</b> <code class="inline">StepLogger</code> să fie unic și comun pentru UI și API.</li>
    <li><b>MUST NOT</b> testele / serviciile / validările să apeleze adaptoare direct.</li>
  </ul>
</details>

<details>
  <summary>3.2 Reguli de pași (StepLogger) <span class="sumhint">single-source step semantics</span></summary>

  <div class="rule">
  <ul>
  <li>Regulile din această secțiune se aplică exclusiv layere-lor de execuție
    (<code class="inline">UIActions</code>, <code class="inline">Services</code>, <code class="inline">Validation</code>).</li>
   <li><b>Test Layer</b> nu este un consumer valid de <code class="inline">StepLogger</code>.</li>
  </div>

  <h4>Creare &amp; finalizare</h4>
  <ul>
    <li><b>MUST</b> fiecare pas să fie creat exclusiv prin <code class="inline">StepLogger.startStep(...)</code>.</li>
    <li><b>MUST</b> exista exact un rezultat final per pas: <code class="inline">PASS</code> sau <code class="inline">FAIL</code>.</li>
    <li><b>MUST NOT</b> permite un al doilea <code class="inline">FAIL</code> pentru același pas.</li>
    <li><b>MUST NOT</b> permite crearea unui pas nou cât timp există un pas activ.</li>
  </ul>

  <h4>Detalii (logging)</h4>
  <ul>
    <li><b>MUST</b> <code class="inline">logDetail(...)</code>, <code class="inline">pass(...)</code> și <code class="inline">fail(...)</code> să fie apelate doar în interiorul unui pas activ.</li>
    <li><b>MUST NOT</b> <code class="inline">StepLogger.logDetail(...)</code> în afara unui pas activ.</li>
  </ul>

  <h4>Excepții în afara pașilor</h4>
  <ul>
    <li><b>MUST</b> orice excepție apărută în afara unui pas activ să producă <code class="inline">FAIL</code> la nivel de test (nu doar log), rutată prin <code class="inline">TestListener</code>.</li>
  </ul>

  <h4>Stacktrace &amp; screenshot</h4>
  <ul>
    <li><b>MUST</b> stacktrace-ul să fie randat o singură dată, numai în step-ul care a eșuat, exclusiv ca <b>code block</b> (monospace).</li>
    <li><b>MUST</b> screenshot-ul să fie capturat exclusiv din <code class="inline">TestListener</code>, o singură dată per test <code class="inline">FAIL</code>, la nivel de test.</li>
  </ul>

  <details>
    <summary>Exemplu UI <span class="sumhint">interacțiune</span></summary>
    <pre><code>▶ Type into element: Email
  • locator=input[data-test='email']
  • value=test@example.com
  ✅ PASS: Typed</code></pre>
  </details>

  <details>
    <summary>Exemplu API <span class="sumhint">request + validation</span></summary>
    <pre><code>▶ POST /public/v2/users
  • method=POST
  • url=https://gorest.co.in/public/v2/users
  • request.body={...}
  • response.status=201
  • response.body={...}
  ✅ PASS: Call completed
▶ Validate status: expect 201
  • actual=201
  ✅ PASS: Validated</code></pre>
  </details>
</details>

<details>
  <summary>3.3 UI: interacțiuni &amp; waits <span class="sumhint">uiactions + uiengine + waitutils</span></summary>
  <h4>Interacțiuni</h4>
  <ul>
    <li><b>MUST</b> toate interacțiunile UI să fie executate exclusiv prin <code class="inline">UIActions</code>.</li>
    <li><b>MUST</b> <code class="inline">UIEngine</code> să expună doar operații de bază (click, type, getText, wait), fără logică de test sau reporting.</li>
    <li><b>MUST</b> framework-ul să livreze două implementări concrete de <code class="inline">UIEngine</code> (Selenium și Playwright), selectabile prin configurație.</li>
    <li><b>MUST</b> UIEngine-ul activ să standardizeze dimensiunea browser-ului (implicit <code class="inline">2560×1440</code>), indiferent de engine.</li>
  </ul>

  <h4>Waits</h4>
  <ul>
    <li><b>MUST</b> toate așteptările explicite să fie realizate exclusiv prin <code class="inline">WaitUtils</code>.</li>
    <li><b>MUST</b> decizia de a aplica explicit wait să fie luată în <code class="inline">UIActions</code>, în mod engine-aware.</li>
    <li><b>MUST NOT</b> <code class="inline">WaitUtils</code> să emită FAIL direct; FAIL este controlat exclusiv la nivel de step.</li>
  </ul>

  <h4>Strategie engine-aware</h4>
  <ul>
    <li><b>MUST</b> <code class="inline">UIEngine</code> să expună <code class="inline">boolean supportsAutoWait()</code>.</li>
    <li><b>MUST</b> Selenium → <code class="inline">false</code>, Playwright → <code class="inline">true</code>.</li>
    <li><b>MUST</b> <code class="inline">UIActions</code> să decidă aplicarea wait înainte de interacțiuni.</li>
  </ul>

  <pre><code class="language-java">private static void waitIfRequired(String cssSelector) {
  if (!DriverManager.getEngine().supportsAutoWait()) WaitUtils.waitForVisible(cssSelector);
}</code></pre>
</details>

<details>
  <summary>3.4 Validation Layer <span class="sumhint">assertions &amp; verdict</span></summary>
  <ul>
    <li><b>MUST</b> toate aserțiunile să fie realizate exclusiv în Validation Layer.</li>
    <li><b>MUST</b> validările să fie expuse prin clase reutilizabile.</li>
    <li><b>MAY</b> Validation Layer să creeze pași de tip <em>Validate</em> în raport, folosind <code class="inline">StepLogger</code>.</li>
    <li><b>MUST</b> un eșec de validare să marcheze testul ca <em>FAILED</em> fără a opri execuția testelor următoare.</li>
  </ul>
</details>

<details>
  <summary>3.5 API: services <span class="sumhint">services only</span></summary>
  <h4>Test Layer</h4>
  <ul>
    <li><b>MUST</b> testele să orchestreze exclusiv prin <code class="inline">Services</code>, <code class="inline">Factories/Builders</code> și <code class="inline">Validators</code>.</li>
    <li><b>MUST NOT</b> testele să execute apeluri HTTP sau să facă raportare; orice utilizare a <code class="inline">StepLogger</code> din Test Layer este interzisă.</li>
  </ul>

  <h4>Services</h4>
  <ul>
    <li><b>MUST</b> să definească endpoint-ul prin <code class="inline">basePath</code>.</li>
    <li><b>MUST</b> să expună metode de business.</li>
    <li><b>MUST NOT</b> să conțină aserțiuni sau validări.</li>
  </ul>

  <h4>Execuție HTTP</h4>
  <ul>
    <li><b>MUST</b> execuția apelurilor HTTP să fie delegată unui layer comun reutilizabil.</li>
    <li><b>MUST</b> URL-ul complet să fie construit ca <code class="inline">{base.url.api} + relativePath</code>.</li>
    <li><b>MUST</b> layer-ul de execuție să returneze obiectul <code class="inline">Response</code>.</li>
  </ul>

  <h4>Request/Response Models</h4>
  <ul>
    <li><b>MUST</b> modelele de request să fie construite exclusiv prin Factories sau Builders.</li>
    <li><b>MUST NOT</b> testele să construiască manual payload-uri JSON.</li>
  </ul>

  <h4>Naming semantic pentru pași API</h4>
  <ul>
    <li><b>MUST</b> pașii HTTP: <code class="inline">HTTP {METHOD} {relativePath}</code>; URL-ul complet MUST fi inclus în details.</li>
    <li><b>MUST</b> pașii de validare: <code class="inline">Validate: {expectations}</code> (ex. <code class="inline">status=201</code>, <code class="inline">schema ok</code>).</li>
  </ul>
</details>

<details>
  <summary>3.6 Reporting: engines &amp; adapters <span class="sumhint">architectural vs engine-specific</span></summary>

  <h4>Reguli generale (indiferent de engine)</h4>
  <ul>
    <li><b>MUST</b> selecția engine-ului să fie controlată exclusiv de <code class="inline">ReportingManager</code>, pe baza <code class="inline">reporting.engine</code>.</li>
    <li><b>MUST</b> adaptoarele să implementeze <code class="inline">ReportLogger</code> și să fie accesate exclusiv prin <code class="inline">ReportingManager</code>.</li>
    <li><b>MUST NOT</b> testele, serviciile sau validările să apeleze direct adaptoare.</li>
    <li><b>MUST</b> adaptoarele inactive să fie NO-OP și să nu arunce excepții.</li>
  </ul>

  <details>
    <summary>Constrângeri engine-specific (non-architectural) <span class="sumhint">scope engine-specific</span></summary>
    <ul>
      <li><b>Extent</b>: lifecycle test gestionat de <code class="inline">TestListener</code>; necesar <code class="inline">flush()</code>.</li>
      <li><b>Allure</b>: lifecycle test gestionat de <code class="inline">AllureTestNg</code>; <code class="inline">startTest/endTest/flush</code> sunt NO-OP.</li>
      <li><b>Allure</b>: ordinea listener-ilor este critică (AllureTestNg înainte de TestListener) pentru atașamente și închidere corectă.</li>
    </ul>
  </details>
</details>

<details>
  <summary>3.7 Contract canonic de raportare <span class="sumhint">reportlogger</span></summary>
  <ul><li><b>ReportLogger</b> MUST expune EXACT următoarele metode:</li></ul>
  <pre><code>void startTest(String testName, String description);
void endTest(String status);            // PASS | FAIL | SKIP
void startStep(String stepTitle);
void logDetail(String detail);
void pass(String message);
void fail(String message, String stacktraceAsText);
void attachScreenshotBase64(String base64, String title);
void logCodeBlock(String content);
void flush();</code></pre>

  <div class="note">
<b>Notă:</b> 
<ul>
	<li>Pentru engine-uri cu lifecycle manual (ex. <code class="inline">Extent</code>),
	metodele <code class="inline">startTest</code>, <code class="inline">endTest</code> și <code class="inline">flush</code> sunt relevante.</li>
	<li>Pentru <code class="inline">Allure</code>, lifecycle-ul testului este controlat de <code class="inline">AllureTestNg</code>,
	iar aceste metode sunt NO-OP.</li>
</div>
</details>

<details>
<summary>3.8 CSS &amp; aspect (Extent)  <span class="sumhint">style</span></summary>
<ul>
    <li><b>MUST</b> adaptorul Extent să seteze explicit tema Theme.DARK.</li>
    <li><b>MUST</b> să aplice explicit CSS-ul prin ExtentSparkReporter.setCss(...), definit ca string final, hardcoded.</li>
</ul>
<pre><code>.card-title a span { color: #f2f2f2 !important; }
.card-title a { color: #f2f2f2 !important; }
.fa { color: #f2f2f2 !important; }</code></pre>
</details>

<details>
  <summary>3.9 Constrângeri globale <span class="sumhint">reguli globale</span></summary>
  <ul>
    <li><b>MUST</b> toate dependințele framework-ului să fie disponibile la runtime.</li>
    <li><b>MUST NOT</b> fie declarate dependințe cu <code class="inline">&lt;scope&gt;test&lt;/scope&gt;</code>.</li>
    <li><b>MUST NOT</b> fie utilizate numele de metode <code class="inline">wait</code>, <code class="inline">notify</code>, <code class="inline">notifyAll</code>, <code class="inline">finalize</code>.</li>
    <li><b>MUST</b> existe un singur <code class="inline">pom.xml</code> la rădăcina proiectului.</li>
    <li><b>MUST NOT</b> fie definite module Maven separate (<code class="inline">&lt;modules&gt;</code>).</li>
  </ul>
</details></div>
<hr class="sep"/>
<div class="card">
<h2>4) Organizarea testelor — DEMO</h2>
<div class="split">
<div class="mini">
<details>
<summary><span class="label">UI</span> — cerințe de test (MUST)</summary>
<div class="details-body">
<ul>
<li><b>Target UI (config):</b> <code>{base.url}</code> = <code>https://practicesoftwaretesting.com</code></li>
<li><b>Pagină de înregistrare (MUST):</b> <code>{base.url}/auth/register</code> (ex.: <code>https://practicesoftwaretesting.com/auth/register</code>)</li>
</ul>
<ul>
<li><b>MUST</b> minim: 1 test pozitiv + 3 negative</li>
<li><b>MUST</b> navigare obligatorie: <code>{base.url}/auth/register</code></li>
<li><b>MUST</b> layering: <code>Tests → Services → Pages/Validation</code></li>
<li><b>MUST NOT</b> acces direct la UI engine</li>
<li><b>Positive:</b> validare înregistrare cu mesaj de confirmare</li>
<li><b>Negative:</b> email invalid/duplicat, lipsă câmpuri obligatorii, password mismatch (dacă există)</li>
</ul>
</div>
<details>
<summary>Detalii suplimentare<span class="sumhint">locators &amp; test data</span></summary>
<h4>Locatori</h4>
<ul>
<li><b>CSS selectors</b> MUST be used.</li>
<li><b>XPath</b> ONLY when CSS cannot express text matching.</li>
</ul>
<pre><code>button[data-test='submit']
xpath: //button[text()='Register']</code></pre>
<div class="note">
<b>Demo / POC Guidance:</b>
<ul>
	<li>Pentru demo sau POC, locatorii POT fi defensivi (ex. id, name, data-test),
	pentru a tolera variații minore de UI.</li>
	<li>Această regulă MUST fi adaptată pentru aplicații reale.</li>
</div>
<h4>Date de test</h4>
<ul>
<li>Toate datele de test MUST fie JSON sub <code class="inline">src/test/resources/testdata</code>.</li>
<li>Datele unice MUST fi generate prin <code class="inline">DataGenerator</code>.</li>
</ul>
</details></details>
</div>
<div class="mini">
<details>
<summary><span class="label">API</span> — cerințe de test (MUST)</summary>
<div class="details-body">
<ul>
<li><b>Target API (config):</b> <code>{base.url.api}</code> = <code>https://gorest.co.in</code></li>
</ul>
<ul>
<li><b>MUST</b> teste complet independente (ordine irelevantă)</li>
<li><b>MUST</b> cleanup pentru datele create</li>
<li><b>MUST</b> GET/UPDATE/DELETE: fiecare test își creează entitatea în setup</li>
<li><b>MUST</b> ierarhie: Positive / Negative / End-to-end</li>
<li><b>MUST</b> E2E: Create → Get → Update → Delete → Verify deletion</li>
<li><b>MUST</b> JSON Schema validation în pași logați (schemas version-controlled)</li>
</ul>
</div>
<details>
<summary>API under test (gorest) <span class="pill">base + endpoints</span></summary>
<div class="details-body">
<pre><code>Base URL (config): {base.url.api} = https://gorest.co.in

POST  /public/v2/users            -&gt; expect 201
GET  /public/v2/users/{user_id}   -&gt; expect 200
PUT  /public/v2/users/{user_id}   -&gt; expect 200/201
PATCH /public/v2/users/{user_id}  -&gt; expect 200/201
DELETE /public/v2/users/{user_id} -&gt; expect 204</code></pre>
</div>
</details><details><summary>Autentificare &amp; Autorizare (API) <span class="sumhint">auth.token</span></summary>
<ul>
<li><b>MUST</b> token-ul de autentificare să fie definit în config:
    <code class="inline">auth.token</code>.</li>
<li><b>MUST</b> autentificarea să fie gestionată centralizat (ex: <code class="inline">ApiClient</code>).</li>
<li><b>MUST NOT</b> testele să construiască manual headere de autentificare.</li>
<li><b>MUST NOT</b> token-ul să fie hardcodat în teste.</li>
<li>Pentru operații POST / PUT / PATCH / DELETE:
  <ul>
<li><b>MUST</b> token prezent.</li>
<li>Lipsa token-ului → <b>SKIP</b> sau <b>FAIL</b> controlat, explicit.</li>
</ul>
</li>
</ul>
</details></details>
</div>
</div>
<details>
<summary>Listeners + BaseTests + testng.xml</summary>
<div class="details-body">
<div class="split"><div class="mini">
<div class="muted"><b>BaseTestUI</b> (toate testele UI extind această clasă)</div>
<pre><code>@Listeners({
    AllureTestNg.class,
    TestListener.class
})
public abstract class BaseTestUI {

  @BeforeMethod(alwaysRun = true)
  public void setUp() {
    ConfigManager.load();
    DriverManager.initEngine();
  }

  @AfterMethod(alwaysRun = true)
  public void tearDown() {
    DriverManager.quitEngine();
  }
}</code></pre>
</div><div class="mini">
<div class="muted"><b>BaseTestAPI</b> (toate testele API extind această clasă)</div>
<pre><code>@Listeners({
    AllureTestNg.class,
    TestListener.class
})
public abstract class BaseTestAPI {

  @BeforeClass(alwaysRun = true)
  public void baseSetup() {
    ApiClient.init();
    requireTokenForWrites();
  }

  protected void requireTokenForWrites() {
    String token = ConfigManager.get("auth.token");
    if (token == null || token.isBlank()) {
      throw new SkipException("auth.token is not set; GoRest write operations require a token");
    }
  }
}</code></pre>
</div>
</div>
<div class="muted" style="margin-top:12px;"><b>testng.xml</b> (structurare / listeners la nivel suită)</div>
<pre><code>&lt;suite name="Framework Suite" parallel="false"&gt;
 &lt;listeners&gt;
  &lt;listener class-name="io.qameta.allure.testng.AllureTestNg"/&gt;
  &lt;listener class-name="com.endava.ai.ui.core.TestListener"/&gt;
 &lt;/listeners&gt;

 &lt;test name="UI Tests"&gt;
  &lt;packages&gt;
   &lt;package name="com.endava.ai.ui.tests"/&gt;
  &lt;/packages&gt;
 &lt;/test&gt;

 &lt;test name="API Tests"&gt;
  &lt;packages&gt;
   &lt;package name="com.endava.ai.api.tests"/&gt;
  &lt;/packages&gt;
 &lt;/test&gt;
&lt;/suite&gt;</code></pre>
</div>
<div class="warn">
<b>Regulă:</b> <code class="inline">AllureTestNg</code> se înregistrează înaintea <code class="inline">TestListener</code> pentru ca raportarea să fie inițializată corect înainte de atașamente și închiderea testului.
</div>
</details>
</div>
<hr class="sep"/>
<div class="card">
  <h2>5) Artefacte livrare</h2>
  <div class="split">
    <div class="mini">
      <h3>UI</h3>
      <ul>
        <li>Parte a aceluiași proiect Maven</li>
        <li><code class="inline">pom.xml</code>, <code class="inline">framework.properties</code>, <code class="inline">testng.xml</code>, <code class="inline">README.md</code></li>
        <li><code class="inline">README.md</code> MUST: explică configurarea proiectului, pașii de execuție, abordarea de testare și strategia de raportare.</li>
      </ul>
    </div>
    <div class="mini">
      <h3>API</h3>
      <ul>
        <li>Parte a aceluiași proiect Maven</li>
        <li><code class="inline">pom.xml</code>, <code class="inline">framework.properties</code>, <code class="inline">testng.xml</code>, <code class="inline">README.md</code></li>
        <li><code class="inline">README.md</code> MUST: explică configurarea proiectului, pașii de execuție, abordarea de testare și strategia de raportare.</li>
      </ul>
    </div>
  </div>
</div>
</div>
</body>
</html>
